def rational_functions_to_pols( gens ):    
    
    primes_of_denoms = []
    exponents_of_primes_in_denoms = []
    units = []
    
    # get the parent pol ring
    P = gens[0].numerator().parent()
    P = P.change_ring(P.base_ring().fraction_field())
    P_gens = P.gens()
    nr_gens = len(gens)
    n = len(P.gens())
    F = P.base_ring()
    if not F.is_field():
        F = F.fraction_field()


    for g in gens:
        exps = []
        d = g.denominator()
        fact = d.factor()
        units.append( F( fact.unit()))

        for f in fact:
            if f[0] in primes_of_denoms:
                ind = primes_of_denoms.index( f[0] )
                exps.append( (ind, f[1]) )
            else:
                primes_of_denoms.append( f[0])
                exps.append( (len(primes_of_denoms)-1, f[1] ))
        exponents_of_primes_in_denoms.append( exps )    
    
    
    P1 = PolynomialRing( F, n + len( primes_of_denoms), 'xx' )
    
    new_gens = []
    subs = { P.gens()[k]: P1.gens()[k] for k in range( n )}
    #return subs
    for i in range( len( gens )):
        g = gens[i]
        #print( g.numerator(), P )
        g1 = P(g.numerator()).subs( subs )
        #print( exps )
        g1 *= (units[i]**-1)*prod( [ (P1.gens()[n+ex[0]])**ex[1] for ex in exponents_of_primes_in_denoms[i] ])
        new_gens.append( g1 )

    #print( primes_of_denoms )
    #return primes_of_denoms, subs
    for i in range( len( primes_of_denoms )):
        p = P(primes_of_denoms[i])
        pp = p.subs( subs )
        new_gens.append( pp*P1.gens()[n+i]-1 )

    return new_gens  

#-------------
def alg_dependence( gens ):
    r''' 
    INPUT: 
        
        - list of polynomials in multivariate polynomial ring
    
    OUTPUT: 
    
        - Groebner basis for the ideal of polynomials that give zero if the elements of gens are subtituted.
    
    EXAMPLES:
    
        sage: gens[0]*gens[1]+gens[1]*gens[2]-gens[0]

        x0^2*x1 - x0^2*x2 - x0^2 + x1*x2*x3 - x2^2*x3

        sage: gens = [x0^2,x1-x2,x2*x3,x0^2*x1 - x0^2*x2 - x0^2 + x1*x2*x3 - x2^2*x3]

        sage: dep = alg_dependence( gens )

        sage: dep

        [t0*t1 - t0 + t1*t2 - t3]

        sage: dep[0].subs( t0=gens[0],t1=gens[1],t2=gens[2], t3 = gens[3] )

        0
        
    '''
    P = gens[0].parent()
    P_gens = P.gens()
    nr_gens = len(gens)
    n = len(P.gens())
    F = P.base_ring()

    R = PolynomialRing( F, n+nr_gens, 'z' )
    rgens = R.gens()

    rxgens, rzgens = rgens[0:n], rgens[n:n+nr_gens]
    idgens = [ gens[i].subs( { P_gens[j]: rxgens[j] for j in range(n)}) - 
                        rzgens[i] for i in range( nr_gens )]

    I = R.ideal( idgens )
    gr = I.groebner_basis()
    
    n_zeros = tuple( 0 for _ in range( n ))
    #return gr, n, n_zeros
    cent_gens = [ g for g in gr if g.degrees()[0:n] == n_zeros ]
    #return cent_gens

    R1 = PolynomialRing( F, nr_gens, 't', order = "invlex" ) ### check if the right order is used
    values = { R.gens()[i]: 0 for i in range( n )}
    values.update( { R.gens()[i+n]: R1.gens()[i] for i in range( nr_gens )})
    new_gens = [ x.subs( values ) for x in cent_gens ]
    
    return R1.ideal( new_gens ).groebner_basis()
    
#-------------

#-------------
def is_element_of_subalgebra( gens, p ):
    '''
        INPUT:
        
            - a list of polynomials `gens`
            - a polynomial `p`
            
        OUTPUT:
            
            - true/false depending on whether p lies in the algebra generated by gens
            - in case of true, returns a polynomial r such that r( gens ) == p 

        Finds if the polynomial `p` lies in the algebra generated by gens.
        
        EXAMPLES:
        
            sage: gens = [x0^2,x1-x2,x2*x3]

            sage: p = x0^2*x1 - x0^2*x2 - x0^2 + x1*x2*x3 - x2^2*x3

            sage: v, dep = is_element_of_subalgebra( gens, p )

            sage: v

            True

            sage: dep

            [t0*t1 - t0 + t1*t2]

            sage: dep[0].subs( t0=gens[0],t1=gens[1],t2=gens[2] ) == p

            True
    '''

    gens_new = rational_functions_to_pols( gens + [p] )
    nr_fake_gens = len( gens_new ) - len( gens )
    #print( "new_gens are ", gens_new )
    #return gens_new
    deps = alg_dependence( gens_new )
    #return deps 
    d = len( gens )
    
    if len( deps ) == 0:
        return false, _
    
    R = deps[0].parent()
    R_gens = [ x for x in R.gens()[0:len(gens)+1]]
    R_gens += [ 0 for _ in range( nr_fake_gens-1 )]
    r_subs = { R.gens()[i]: R_gens[i] for i in range( len( R.gens()))}
    deps = [ x for x in deps if R.gens()[d] in x.monomials() ]

    if len( deps ) == 0:
        return false, []

    #return deps
    deps = [ d.subs( r_subs ) for d in deps ]
    
    coeffs = [ x.coefficient( R.gens()[d] ) for x in deps ]
    deps = [ -(coeffs[k]**-1)*deps[k] for k in range( len( deps )) ]
    
    #print( deps )

    expressions = [ deps[i] + (R.gens()[d]) for i in range( len( deps )) ]

    degR = len( R.gens())
    R0 = PolynomialRing( QQ, len(gens), [ str( R.gens()[x] ) for x in range( len(gens))])

    #return expressions
    return true, [ R0( x ) for x in expressions ]


def is_element_of_subalgebra_localization( gens, p, q, nr_tries = 100 ):

    k = 0
    while k <= nr_tries:
        v, h = is_element_of_subalgebra( gens, p*q**k )
        if v:
            return h[0], k 
        k += 1

    return false
#-------------