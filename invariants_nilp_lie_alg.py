from sage.all import QQ, PolynomialRing


def differential_operator(L, x, leading_char='x'):
    r'''
        INPUT:
        - Lie algebra `L` and
        - an element `x` of `L`.
        - `leading_char`: character to be used if basis elements are not 
           strings or do not start with letters. 
        
        OUTPUT:
        - the differential operator that corresponds to the element x acting
          on the polynomial algebra generated by L.basis().
            
        COMMENT:

        Constructs the differential operators on the polynomial algebra
        generated by the L.basis() that corresponds to the adjoint action
        of the element `x` on `L`. If `L` is a Lie algebra with basis 
        `x_1,\ldots,x_n`, and `d_{x_i}` is the partial derivative by `x_i`,
        then the differential operator is defined as
       
        .. MATH::
       
            \sum_{i=1}^{\dim L} [x,x_i]d_{x_1}

        The function only works for Lie algebras whose elements are written as
        linear combination of basis elements and can be considered as linear
        polynomials in the basis elements.

        TODO:
        Extend to Lie algebras whose elements are not linear combinations of 
        the basis elements.
        For example lie_algebras.ClassicalMatrix(QQ, ['A',3]).

        EXAMPLES::
            sage: differential_operator( l, l.basis()['E13'] )
            E12 + E13 + E14 + E15 + E23 + E24 + E25 + E34 + E35 + E45
            E14*d/dE34 + E15*d/dE35
    '''
    
    # compute base ring and dimensions of L
    F, d = L.base_ring(), L.dimension()
    
    # if L already has L.polynomialRing, then we use that.
    if hasattr(L, "polynomialRing"):
        P = L.polynomialRing
        F = L.fractionField
    else:
        # else we construct the L.polynomialRing
        basis_keys = L.basis().keys()
        # the generators of the polynomial ring are formed from 
        # the basis of L. If the keys of the basis dictionary are not 
        # strings or do not start with letter, then it is fixed.
        if isinstance(basis_keys[0], str) and basis_keys[0][0].isalpha():
            pol_gens = list(basis_keys)
        elif isinstance(basis_keys[0], str):
            pol_gens = [leading_char+str(k) for k in L.basis().keys()]
        else:
            pol_gens = [leading_char+str(k) for k in L.basis().keys()]
    
        # construct polynomial ring, fraction field and store them
        P = PolynomialRing(F, d, pol_gens)
        F = P.fraction_field()
        L.polynomialRing = P
        L.fractionField = F
    
    # now see if elements of L can be viewed as linear polynomoils in P.
    # If not, raise error.
    try:
        P(L.an_element())
    except TypeError:
        raise TypeError("Lie algebra elements cannot be viewed as polynomials")

    # now construct the differential operator
    bas = L.basis()
    return sum(P(L.bracket(x, y))*P.derivation(P(str(y))) for y in bas)


def differential_operator_from_coeffs(P, coeffs):
    r"""
    """

    D = P.derivation_module()
    op = D.zero()
    
    for k in range(len(coeffs)): 
        op += coeffs[k]*D.gens()[k]

    return op



def derivation_kernel(d, phi=0):
    r'''
        INPUT:
        - `d`: triangular differential operator
        - `phi`: subsptitution of variables
        
        OUTPUT:
        - algebraically independent generators for the kernel of d
        inside the field of rational functions.

        COMMENT:
        
        EXAMPLES::
    '''

    domain_d = d.domain()
    if not domain_d.is_field():
        frac_domain_d = domain_d.fractionField()
    else:
        frac_domain_d = domain_d 

    ring_domain_d = frac_domain_d.ring()
    emb = frac_domain_d.coerce_map_from(ring_domain_d).section()

    gens = [0]*len(frac_domain_d.gens())
    for i in range(len(gens)):
        gens[i] = emb(frac_domain_d.gens()[i])
    if phi != 0:
        gens_domain_phi = phi.domain().gens()
        gens = [0]*len(gens_domain_phi)
        for i in range(len(gens_domain_phi)):
            f = phi(gens_domain_phi[i])
            f.reduce()
            gens[i] = emb(f.numerator())
            #gens[i] = f
    len_gens = len(gens)
    pols = [0]*len_gens
    curve = [0]*len_gens
    inicial_value = [0]*(len_gens - 1)
    S = PolynomialRing(QQ, len_gens - 1, "y")
    FracS = FractionField(S)
    HomFracSR = Hom(FracS,frac_domain_d)
    for i in range(len_gens):
        f = d(gens[i])
        f.reduce()
        pols[i] = f
    if pols[0] != 0:
        return False
    first_not_zero = 0
    for i in range(len_gens):
        if pols[i] == 0:
            first_not_zero = first_not_zero + 1
        else:
            break
    if first_not_zero == len_gens:
        S = PolynomialRing(QQ, len_gens, "y")
        FracS = FractionField(S)
        HomFracSR = Hom(FracS,frac_domain_d)
        phi = HomFracSR(gens)
        return phi
    for i in range(first_not_zero):
        curve[i] = gens[i]
        inicial_value[i] = curve[i]
    if first_not_zero == len_gens - 1:
        phi = HomFracSR(inicial_value)
        return phi
    P = PolynomialRing(frac_domain_d, "t")
    t = P.gens()[0]
    curve[first_not_zero] = pols[first_not_zero]*t
    q = gens[first_not_zero]/pols[first_not_zero]
    for i in range(first_not_zero + 1, len_gens):
        if pols[i] == 0:
            curve[i] = gens[i]
            inicial_value[i-1] = curve[i]
        else:
            list_pols = [0]*i
            for j in range(i):
                list_pols[j] = gens[j]
            is_el = is_element_of_subalgebra(list_pols,pols[i])
            if is_el[0] == False:
                return False
            aux_c = is_el[1][0]

            der_aux_c = P(aux_c.subs({aux_c.parent().gens()[j] : curve[j] for j in range(i)}))
            curve_without_const = der_aux_c.integral()
            inicial_value[i-1] = gens[i] - curve_without_const.subs({t:q})
            curve[i] = curve_without_const + inicial_value[i-1]

    return curve
    for i in range(len_gens - 1):
        inicial_value[i] = inicial_value[i].numerator()
        inicial_value[i] = inicial_value[i]*inicial_value[i].denominator()
        inicial_value[i] = inicial_value[i]/1
    for i in range(1,len_gens - 1):
        for j in range(i):
                if inicial_value[j].divides(inicial_value[i]):
                    inicial_value[i] = inicial_value[i]/inicial_value[j]
                    inicial_value[i] = inicial_value[i].numerator()
                    inicial_value[i] = inicial_value[i]*inicial_value[i].denominator()
    phi = HomFracSR(inicial_value)
    return phi
#-------------

#-------------
def method_characteristics_diagonal(d, phi = 0):
    domain_d = d.domain()
    frac_domain_d = FractionField(domain_d)
    ring_domain_d = frac_domain_d.ring()
    gens = frac_domain_d.gens()
    if phi != 0:
        gens = phi
    coeff = [d(gens[i]) for i in range(len(gens))]
    first_not_zero = 0
    aux_bool = True
    while aux_bool:
        if coeff[first_not_zero] == 0:
            first_not_zero = first_not_zero + 1
        else:
            aux_bool = False
        if first_not_zero == len(coeff):
            return gens
    a = ring_domain_d(coeff[first_not_zero].numerator()).coefficients()[0]
    asign = a.sign()
    aabs = a.abs()
    s = gens[first_not_zero]**asign
    inv = [gens[i] for i in range(first_not_zero)]
    for i in range(first_not_zero + 1, len(gens)):
        if coeff[i] == 0:
            inv = inv + [gens[i]]
        else:
            a = ring_domain_d(coeff[i].numerator()).coefficients()[0]
            inv = inv + [gens[i]/s**(a/aabs)]
    return inv
#-------------

#-------------
def generators_algebra_rational_invariants(L, needs_basis_change=True):
    bL = L.basis().list()

    if needs_basis_change:
        bEspL = triangular_basis_lie_algebra(L)
        Lesp = base_change_nilp_lie_alg(L, bEspL)
    else:
        bEspL = L.basis().list()
        Lesp = L 

    #bEspLesp = triangular_basis_lie_algebra(Lesp)
    bEspLesp = Lesp.basis().list()
    dimL = len(bL)
    F = Lesp.base_ring()
    P = PolynomialRing( F, dimL, list(Lesp.basis().keys()) )
    Lesp.polynomialRing = P
    Lesp.fractionField = P.fraction_field()
    x = Lesp.polynomialRing.gens()

    if Lesp.center().dimension() == dimL:
        HomFracSR = Hom(Lesp.fractionField,Lesp.fractionField)
        phi = HomFracSR.identity()
        return [phi(phi.domain().gens()[i]) for i in range(len(phi.domain().gens()))]

    first_not_center = 0
    while Lesp.gens()[first_not_center] in Lesp.center():
        first_not_center = first_not_center + 1

    d = differential_operator(Lesp, bEspLesp[first_not_center])
    phi = method_characteristics_nilpotent(d)
    if phi == False:
        return False
    for i in range(first_not_center+1, dimL):
        d = differential_operator(Lesp, bEspLesp[i])
        #phi0 = phi
        phi = method_characteristics_nilpotent(d, phi)
        #print( "succeed", d )
        if phi == False:
            return False#, phi0, d

    FracS = phi.domain()
    gens_domain_phi = phi.domain().gens()
    gens_codomain_phi = phi.codomain().gens()
    HomFracSR = Hom(FracS,Lesp.fractionField)
    HR = [0]*(len(gens_domain_phi))
    for i in range(len(gens_domain_phi)):
        HR[i] = phi(gens_domain_phi[i]).subs({gens_codomain_phi[k] : x[k] for k in range(len(gens_codomain_phi))})
    
    y = [0]*dimL
    for i in range(dimL):
        for j in range(dimL):
            y[i] = y[i] + coord_base(L, bL, bEspL[i])[j]*x[j]
    
    for i in range(len(gens_domain_phi)):
        HR[i] = HR[i].subs({P.gens()[k] : y[k] for k in range(dimL)})
    
    L2 = base_change_nilp_lie_alg(L, bL)
    bEspL2 = triangular_basis_lie_algebra(L2)
    xstr1 = [str(i) for i in bEspL]
    xstr2 = [str(i) for i in bEspL2]
    Pol1 = PolynomialRing( F, dimL, xstr1 )
    Pol2 = PolynomialRing( F, dimL, xstr2 )
    HomFracPol2Pol1 = Hom(FractionField(Pol2),FractionField(Pol1))
    HR2 = [0]*(dimL)
    for i in range(dimL):
        HR2[i] = Pol1.gens()[i]
    phi = HomFracPol2Pol1(HR2)
    for i in range(len(gens_domain_phi)):
        HR[i] = phi(HR[i])
    
    P3 = PolynomialRing( F, dimL, list(L.basis().keys()))
    HomFracSR = Hom(FracS,FractionField(P3))
    alpha = HomFracSR(HR)
    return [alpha(alpha.domain().gens()[i]) for i in range(len(alpha.domain().gens()))]
#-------------

#-------------
def invariant_field_isomorphism( L, needs_basis_change=True):
    return generators_algebra_rational_invariants( L, 
                                needs_basis_change = needs_basis_change )    
